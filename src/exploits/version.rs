// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

//! Version checking for linux kernel, docker, and runc.

use std::{io::BufRead, ops::Deref, process::Command};

use anyhow::{bail, Context, Result};
use nix::sys::utsname::uname;
use serde::{Deserialize, Serialize};

#[derive(Debug, PartialEq, Eq, Clone, PartialOrd, Ord)]
pub struct Versioning {
    inner: versions::Versioning,
}

impl Versioning {
    pub fn new(v: &str) -> Result<Self> {
        Ok(Self {
            inner: versions::Versioning::new(v)
                .ok_or_else(|| anyhow::anyhow!("invalid version string {}", v))?,
        })
    }
}

impl From<versions::Versioning> for Versioning {
    fn from(v: versions::Versioning) -> Self {
        Self { inner: v }
    }
}

impl From<Versioning> for versions::Versioning {
    fn from(v: Versioning) -> Self {
        v.inner
    }
}

impl TryFrom<&str> for Versioning {
    type Error = anyhow::Error;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        let v = versions::Versioning::try_from(value)
            .map_err(|_| anyhow::anyhow!("invalid version string {}", value))?;
        Ok(Self { inner: v })
    }
}

impl Deref for Versioning {
    type Target = versions::Versioning;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl Serialize for Versioning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.inner.to_string().serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for Versioning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;

        if let Ok((_, ideal)) = versions::SemVer::parse(&s) {
            return Ok(versions::Versioning::Ideal(ideal).into());
        }

        if let Ok((_, general)) = versions::Version::parse(&s) {
            return Ok(versions::Versioning::General(general).into());
        }

        if let Ok((_, complex)) = versions::Mess::parse(&s) {
            return Ok(versions::Versioning::Complex(complex).into());
        }

        return Err(serde::de::Error::custom(format!(
            "unable to parse {} as a version",
            &s
        )));
    }
}

/// Specify a minimum and/or maximum version to compare to.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct VersionComparison {
    #[serde(alias = "minimum")]
    pub min: Option<Versioning>,
    #[serde(alias = "maximum")]
    pub max: Option<Versioning>,
}

impl VersionComparison {
    /// Compare against a known version, returning `Ok` if acceptable or `Err` otherwise.
    pub fn compare(&self, version: Versioning) -> Result<()> {
        let version = strip_version(version);

        if let Some(max) = &self.max {
            let max = &strip_version(max.clone());
            if &version > max {
                bail!("version {:?} is greater than maximum {:?}", version, max);
            }
        }

        if let Some(min) = &self.min {
            let min = &strip_version(min.clone());
            if &version < min {
                bail!("version {:?} is less than minimum {:?}", version, min);
            }
        }

        Ok(())
    }
}

/// Specify which version checks to run.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct VersionCheck {
    pub kernel: Option<VersionComparison>,
    pub docker: Option<VersionComparison>,
    pub runc: Option<VersionComparison>,
}

impl VersionCheck {
    pub fn check(&self) -> Result<()> {
        if let Some(kernel) = &self.kernel {
            let version = get_linux_version().context("failed to get Linux version")?;
            kernel
                .compare(version)
                .context("Linux version check failed")?;
        }

        if let Some(docker) = &self.docker {
            let version = get_docker_version().context("failed to get docker version")?;
            docker
                .compare(version)
                .context("docker version check failed")?;
        }

        if let Some(runc) = &self.runc {
            let version = get_runc_version().context("failed to get runc version")?;
            runc.compare(version).context("runc version check failed")?;
        }

        Ok(())
    }
}

fn get_linux_version() -> Result<Versioning> {
    let version = uname().context("failed to call uname")?;
    let version = version.release();
    let version = version
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("non-UTF-8 version string"))?;
    parse_version(version)
}

fn get_runc_version() -> Result<Versioning> {
    let output = Command::new("runc")
        .arg("--version")
        .output()
        .context("failed to spawn runc command")?;
    if !output.status.success() {
        bail!("runc command failed with {}", output.status);
    }
    for line in output.stdout.lines() {
        let line = line.context("failed to read line from stdout")?;
        if let Some(version) = line.strip_prefix("runc version").map(|line| line.trim()) {
            return parse_version(version);
        }
    }
    bail!("failed to find runc version")
}

fn get_docker_version() -> Result<Versioning> {
    let output = Command::new("docker")
        .arg("--version")
        .output()
        .context("failed to spawn docker command")?;
    if !output.status.success() {
        bail!("docker command failed with {}", output.status);
    }
    for line in output.stdout.lines() {
        let line = line.context("failed to read line from stdout")?;
        if let Some(version) = line
            .strip_prefix("Docker version")
            .and_then(|line| line.trim().split_once(",").map(|s| s.0))
        {
            return parse_version(version);
        }
    }
    bail!("failed to find docker version")
}

fn parse_version(v: &str) -> Result<Versioning> {
    Versioning::new(v)
}

fn strip_version(v: Versioning) -> Versioning {
    if let versions::Versioning::Ideal(version) = v.inner {
        let mut version = version;
        version.pre_rel = None;
        version.meta = None;
        return versions::Versioning::Ideal(version).into();
    }

    if let versions::Versioning::General(version) = v.inner {
        let mut version = version;
        version.meta = None;
        return versions::Versioning::General(version).into();
    }

    return v;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version_compare() {
        let vc = VersionComparison {
            min: None,
            max: Some("5.18.9-arch1-1".try_into().unwrap()),
        };

        vc.compare(Versioning::try_from("5.18.9-arch1-1").unwrap())
            .expect("identical version should be ok");
        vc.compare(Versioning::try_from("5.18.9-foobar").unwrap())
            .expect("should ignore pre-rel");
        vc.compare(Versioning::try_from("5.18.9").unwrap())
            .expect("without pre-rel should be ok");

        vc.compare(Versioning::try_from("5.18.10").unwrap())
            .expect_err("higher patch should be err");
        vc.compare(Versioning::try_from("5.19.0").unwrap())
            .expect_err("higher minor should be err");
        vc.compare(Versioning::try_from("6.0.0").unwrap())
            .expect_err("higher major should be err");
    }

    #[test]
    fn test_get_linux_version() {
        let version = get_linux_version().expect("should be able to get linux version");
        assert!(version.is_ideal());
    }

    #[test]
    fn test_get_runc_version() {
        let version = get_runc_version().expect("should be able to get runc version");
        assert!(version.is_ideal());
    }

    #[test]
    fn test_get_docker_version() {
        let version = get_docker_version().expect("should be able to get docker version");
        assert!(version.is_ideal());
    }
}
