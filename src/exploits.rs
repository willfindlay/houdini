// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

//! This module encapsulates container exploit payloads as well as operations to be run
//! on the host system to bootstrap container exploits.

pub mod report;
mod version;

use std::{
    collections::HashSet,
    io::{stdin, Read},
    os::unix::process::ExitStatusExt as _,
    time::Duration,
};

use anyhow::{bail, Context, Result};
use serde::{Deserialize, Serialize};

use crate::docker::{kill_container, reap_container, spawn_container, ImagePullPolicy};

use self::{
    report::{PlanReport, Report, StepReport},
    version::VersionCheck,
};

fn default_setup_failure() -> ExploitStatus {
    ExploitStatus::SetupFailure
}

fn default_skip() -> ExploitStatus {
    ExploitStatus::Skip
}

fn default_true() -> bool {
    true
}

fn default_false() -> bool {
    false
}

/// A plan for running and verifying a container exploit.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Plan {
    pub name: String,
    steps: Vec<Step>,
}

impl Plan {
    /// Run every step of the exploit plan, returning a final status in the end.
    /// If any step returns a final status, we return that status early.
    pub async fn run(&self, report: Option<&mut Report>) -> ExploitStatus {
        let _guard = tracing::info_span!("running exploit", exploit = ?&self.name).entered();

        let mut containers: HashSet<String> = HashSet::new();
        let mut status = ExploitStatus::Undecided;

        let mut plan_report = if report.is_some() {
            Some(PlanReport::new(&self.name))
        } else {
            None
        };

        for step in &self.steps {
            status = step.run().await;

            if let Step::SpawnContainer { name, .. } = step {
                containers.insert(name.to_owned());
            }

            let step_report = StepReport::new(step, status);
            if let Some(plan_report) = &mut plan_report {
                plan_report.add(step_report);
            }

            if status.is_final() {
                if let Some(plan_report) = &mut plan_report {
                    plan_report.set_status(status);
                }
                break;
            }
        }

        if let Some(report) = report {
            report.add(plan_report.unwrap());
        }

        // Clean up containers
        for id in &containers {
            if let Err(e) = reap_container(id).await {
                tracing::warn!(err = ?e, "failed to reap container");
            }
        }

        status
    }
}

/// An individual step in an exploit plan.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ShellCommand {
    pub command: String,
    pub args: Vec<String>,
}

/// A condition to wait for.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Copy)]
#[serde(rename_all = "camelCase")]
pub enum Wait {
    #[serde(with = "humantime_serde")]
    Sleep(Duration),
    Input {},
}

/// An individual step in an exploit plan.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
#[serde(rename_all = "camelCase")]
pub enum Step {
    /// Check version of software.
    VersionCheck {
        /// Version check defintions.
        #[serde(flatten)]
        version_check: Box<VersionCheck>,
        /// Failure mode for when this step fails. Default is SetupFailure.
        #[serde(default = "default_skip")]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Spawn a container using the docker api.
    SpawnContainer {
        /// Name to assign the container. This is done using the docker api, so commands
        /// like `docker exec -it <name> <command>` will work.
        name: String,
        /// Container image to use for the spawned container.
        image: String,
        /// A policy for what to do when an image is not available. Defaults to pulling
        /// from docker hub if the image does not exist and _no_ SHA256 verification.
        #[serde(default)]
        image_policy: ImagePullPolicy,
        /// Command to run in the container.
        cmd: Option<String>,
        /// Docker volumes for the container.
        #[serde(default)]
        volumes: Vec<String>,
        // TODO: Security opts for container
        //
        //
        /// Spawn the container with extra privileges.
        #[serde(default = "default_false")]
        privileged: bool,
        /// Failure mode for when this step fails. Default is SetupFailure.
        #[serde(default = "default_setup_failure")]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Kill a container using the docker api.
    KillContainer {
        /// Name of the container to kill.
        name: String,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Run a command or commands on the host.
    Host {
        /// Script to run on the host. A non-zero exit status triggers `failure`,
        /// while a zero exit status triggers `success`.
        script: Vec<ShellCommand>,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Run a command in a spawned container. This is done using the docker api.
    Container {
        /// Name of the container to run the command in. Must be the name of a previously
        /// spawned container.
        name: String,
        /// Script to run in the container. A non-zero exit status triggers `failure`,
        /// while a zero exit status triggers `success`.
        script: Vec<ShellCommand>,
        /// Should we run the commands with elevated privileges in the container?
        #[serde(default = "default_false")]
        privileged: bool,
        /// Should we spawn and attach a TTY for these commands?
        #[serde(default = "default_true")]
        tty: bool,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Pause Houdini until a condition occurs.
    Wait {
        #[serde(flatten)]
        for_: Wait,
    },
}

impl Step {
    /// Returns the failure mode of the step.
    fn failure_mode(&self) -> ExploitStatus {
        match self {
            Step::SpawnContainer { failure, .. } => *failure,
            Step::KillContainer { failure, .. } => *failure,
            Step::Host { failure, .. } => *failure,
            Step::Container { failure, .. } => *failure,
            Step::Wait { .. } => ExploitStatus::Undecided,
            Step::VersionCheck { failure, .. } => *failure,
        }
    }

    /// Returns the success mode of the step.
    fn success_mode(&self) -> ExploitStatus {
        match self {
            Step::SpawnContainer { success, .. } => *success,
            Step::KillContainer { success, .. } => *success,
            Step::Host { success, .. } => *success,
            Step::Container { success, .. } => *success,
            Step::Wait { .. } => ExploitStatus::Undecided,
            Step::VersionCheck { success, .. } => *success,
        }
    }

    /// The internal implementation of `Step::run()`.
    async fn do_run(&self) -> Result<()> {
        match self {
            Step::SpawnContainer {
                name,
                image,
                cmd,
                volumes,
                privileged,
                image_policy,
                ..
            } => {
                spawn_container(
                    name,
                    image,
                    image_policy,
                    cmd.as_deref(),
                    volumes,
                    *privileged,
                )
                .await
            }
            Step::KillContainer { name, .. } => kill_container(name).await,
            Step::Host { script, .. } => {
                use std::process::{Command, Stdio};

                for cmd in script {
                    let out = Command::new(&cmd.command)
                        .stdout(Stdio::piped())
                        .stderr(Stdio::piped())
                        .args(&cmd.args)
                        .output()
                        .map_err(anyhow::Error::from)
                        .context("failed to run command")?;

                    let stdout = String::from_utf8(out.stdout).unwrap_or_default();
                    let stderr = String::from_utf8(out.stderr).unwrap_or_default();

                    let cmd_str = std::iter::once(&cmd.command)
                        .chain(&cmd.args)
                        .fold(String::new(), |s, a| s + " " + a);

                    tracing::debug!(
                        stdout = ?stdout,
                        stderr = ?stderr,
                        "command `{}` stdio",
                        cmd_str
                    );

                    let status = out.status;
                    if !status.success() {
                        match status.code() {
                            Some(code) => bail!("command failed with exit code: {}", code),
                            None => {
                                bail!(
                                    "command exited with signal: {}",
                                    status
                                        .signal()
                                        .expect("No signal or exit code for process!?")
                                )
                            }
                        }
                    }
                }

                Ok(())
            }
            Step::Container {
                name,
                script,
                privileged,
                tty,
                ..
            } => {
                use crate::docker::{Command, ExitCode, Stdio};

                for cmd in script {
                    let output = Command::new(name.to_owned(), &cmd.command)
                        .args(&cmd.args)
                        .stdout(Stdio::Piped)
                        .stderr(Stdio::Piped)
                        .tty(*tty)
                        .privileged(*privileged)
                        .output()
                        .await
                        .context("failed to run command in container")?;

                    let stdout = String::from_utf8(output.stdout).unwrap_or_default();
                    let stderr = String::from_utf8(output.stderr).unwrap_or_default();

                    let cmd_str = std::iter::once(&cmd.command)
                        .chain(&cmd.args)
                        .fold(String::new(), |s, a| s + " " + a);

                    tracing::debug!(
                        stdout = ?stdout,
                        stderr = ?stderr,
                        "command `{}` stdio",
                        cmd_str
                    );

                    match output.code {
                        Some(ExitCode(0)) => continue,
                        Some(ExitCode(code)) => {
                            bail!("command failed with exit code: {}", code)
                        }
                        None => {
                            bail!("command did not have an exit status!?")
                        }
                    }
                }

                Ok(())
            }
            Step::Wait { for_ } => {
                match for_ {
                    Wait::Sleep(dur) => {
                        std::thread::sleep(*dur);
                    }
                    Wait::Input {} => {
                        tracing::info!("waiting for input on stdin...");
                        let _ = stdin().read(&mut [0]);
                    }
                };

                Ok(())
            }
            Step::VersionCheck { version_check, .. } => version_check.check(),
        }
    }

    /// Run the step and return either its `Step::success_mode()` or
    /// `Step::failure_mode()` depending on whether it succeeded or not.
    pub async fn run(&self) -> ExploitStatus {
        match self.do_run().await {
            Ok(_) => {
                let status = self.success_mode();
                tracing::info!(step = ?self, status = ?status, "step succeeded");
                status
            }
            Err(e) => {
                let status = self.failure_mode();
                tracing::info!(error = ?e, step = ?self, status = ?status, "step failed");
                status
            }
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Copy)]
#[serde(rename_all = "camelCase")]
pub enum ExploitStatus {
    /// The status of the exploit test is undecided.
    Undecided,
    /// Setup has failed.
    /// This is a final status that stops the plan.
    SetupFailure,
    /// The exploit has succeeded.
    /// This is a final status that stops the plan.
    ExploitSuccess,
    /// The exploit has failed.
    /// This is a final status that stops the plan.
    ExploitFailure,
    /// Skip the exploit.
    /// Like SetupFailure but not considered a hard failure.
    Skip,
}

impl ExploitStatus {
    pub fn is_final(&self) -> bool {
        match self {
            ExploitStatus::Undecided => false,
            ExploitStatus::SetupFailure => true,
            ExploitStatus::ExploitSuccess => true,
            ExploitStatus::ExploitFailure => true,
            ExploitStatus::Skip => true,
        }
    }
}

impl Default for ExploitStatus {
    fn default() -> Self {
        ExploitStatus::Undecided
    }
}

#[cfg(test)]
mod tests {
    use crate::testutils::{assert_json_serialize, assert_yaml_deserialize};

    use super::*;
    use tracing_test::traced_test;

    #[test]
    #[traced_test]
    fn test_yaml_plan_serde_smoke() {
        let yaml = r#"
            name: yaml smoke
            steps:
            - versionCheck:
                docker:
                  min: "1.40.0"
                  max: "1.42"
                kernel:
                  min: "5.14"
                  max: "5.18.8-arch1-1"
                runc:
                  max: "1.1.2"
            - spawnContainer:
                name: bash
                image: bash
            - host:
                script:
                - command: docker
                  args: ["cp", "/etc/passwd", "bash:/passwd"]
                failure: setupFailure
            - wait:
                sleep: 2s
            - wait:
                input: {}
            - container:
                name: bash
                script:
                - command: cat
                  args: ["/passwd"]
                failure: exploitFailure
                success: exploitSuccess
            "#;
        assert_yaml_deserialize::<Plan>(yaml);
    }

    #[tokio::test]
    #[traced_test]
    #[serial_test::serial]
    async fn test_spawn_container() {
        let yaml = r#"
            name: spawn container test
            steps:
            - spawnContainer:
                name: bash
                image: bash
                cmd: sleep infinity
            - host:
                script:
                - command: echo
                  args: ["hello"]
                - command: echo
                  args: ["goodbye"]
                failure: exploitFailure
            - container:
                name: bash
                script:
                - command: echo
                  args: ["hello"]
                - command: echo
                  args: ["goodbye"]
                failure: exploitFailure
                success: exploitSuccess
            "#;

        let plan: Plan = assert_yaml_deserialize(yaml);
        let status = plan.run(None).await;
        assert!(
            matches!(status, ExploitStatus::ExploitSuccess),
            "should succeed"
        );
    }

    #[tokio::test]
    #[traced_test]
    #[serial_test::serial]
    async fn test_exploits_work() {
        use std::path::PathBuf;

        let mut d = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        d.push("exploits");

        let mut report = Report::default();

        for entry in jwalk::WalkDir::new(d)
            .follow_links(false)
            .into_iter()
            .filter_map(Result::ok)
            .filter(|e| e.path().is_file())
        {
            if let Ok(f) = std::fs::File::open(entry.path()) {
                let plan: Plan = serde_yaml::from_reader(f).expect("should deserialize");
                let status = plan.run(Some(&mut report)).await;
                assert!(
                    matches!(status, ExploitStatus::ExploitSuccess | ExploitStatus::Skip),
                    "exploit should succeed"
                );
            }
        }

        assert_json_serialize(&report);
    }
}
