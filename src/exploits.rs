// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

//! This module encapsulates container exploit payloads as well as operations to be run
//! on the host system to bootstrap container exploits.

use std::{
    collections::HashSet,
    io::{stdin, Read},
    os::unix::process::ExitStatusExt as _,
    time::Duration,
};

use crate::CONFIG;
use anyhow::{bail, Context, Result};
use docker_api::{
    api::{ContainerCreateOpts, ContainerId, RmContainerOpts},
    Docker,
};
use serde::{Deserialize, Serialize};

fn default_setup_failure() -> ExploitStatus {
    ExploitStatus::SetupFailure
}

fn default_true() -> bool {
    true
}

fn default_false() -> bool {
    false
}

/// A plan for running and verifying a container exploit.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Plan {
    steps: Vec<Step>,
}

impl Plan {
    /// Run every step of the exploit plan, returning a final status in the end.
    /// If any step returns a final status, we return that status early.
    pub async fn run(&self) -> ExploitStatus {
        let mut containers: HashSet<ContainerId> = HashSet::new();
        let mut status = ExploitStatus::Undecided;

        for step in &self.steps {
            status = step.run().await;

            if let Step::SpawnContainer { name, .. } = step {
                containers.insert(name.to_owned());
            }

            if status.is_final() {
                break;
            }
        }

        // Clean up containers
        for id in &containers {
            let client = Docker::unix(&CONFIG.docker.socket);
            let container = client.containers().get(id);
            let opts = RmContainerOpts::builder().volumes(true).force(true).build();
            if let Err(e) = container.remove(&opts).await {
                tracing::warn!(id = ?id, err = ?e, "failed to remove container");
            }
            let _ = container.wait().await;
        }

        status
    }
}

/// An individual step in an exploit plan.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ShellCommand {
    pub command: String,
    pub args: Vec<String>,
}

/// A condition to wait for.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub enum Wait {
    #[serde(with = "humantime_serde")]
    Sleep(Duration),
    Input {},
}

/// An individual step in an exploit plan.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
enum Step {
    /// Spawn a container using the docker api.
    SpawnContainer {
        /// Name to assign the container. This is done using the docker api, so commands
        /// like `docker exec -it <name> <command>` will work.
        name: String,
        /// Container image to use for the spawned container.
        image: String,
        /// Pull the image if it does not exist on the host.
        #[serde(default = "default_true")]
        pull_image: bool,
        /// Command to run in the container.
        cmd: Option<String>,
        /// Docker volumes for the container.
        #[serde(default)]
        volumes: Vec<String>,
        /// Spawn the container with extra privileges.
        #[serde(default = "default_false")]
        privileged: bool,
        /// Failure mode for when this step fails. Default is SetupFailure.
        #[serde(default = "default_setup_failure")]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Kill a container using the docker api.
    KillContainer {
        /// Name of the container to kill.
        name: String,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Run a command or commands on the host.
    Host {
        /// Script to run on the host. A non-zero exit status triggers `failure`,
        /// while a zero exit status triggers `success`.
        script: Vec<ShellCommand>,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Run a command in a spawned container. This is done using the docker api.
    Container {
        /// Name of the container to run the command in. Must be the name of a previously
        /// spawned container.
        name: String,
        /// Script to run in the container. A non-zero exit status triggers `failure`,
        /// while a zero exit status triggers `success`.
        script: Vec<ShellCommand>,
        /// Should we run the commands with elevated privileges in the container?
        #[serde(default = "default_false")]
        privileged: bool,
        /// Should we spawn and attach a TTY for these commands?
        #[serde(default = "default_true")]
        tty: bool,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Pause Houdini until a condition occurs.
    Wait {
        #[serde(flatten)]
        for_: Wait,
    },
}

impl Step {
    /// Returns the failure mode of the step.
    fn failure_mode(&self) -> ExploitStatus {
        match self {
            Step::SpawnContainer { failure, .. } => *failure,
            Step::KillContainer { failure, .. } => *failure,
            Step::Host { failure, .. } => *failure,
            Step::Container { failure, .. } => *failure,
            Step::Wait { .. } => ExploitStatus::Undecided,
        }
    }

    /// Returns the success mode of the step.
    fn success_mode(&self) -> ExploitStatus {
        match self {
            Step::SpawnContainer { success, .. } => *success,
            Step::KillContainer { success, .. } => *success,
            Step::Host { success, .. } => *success,
            Step::Container { success, .. } => *success,
            Step::Wait { .. } => ExploitStatus::Undecided,
        }
    }

    /// The internal implementation of `Step::run()`.
    async fn do_run(&self) -> Result<()> {
        match self {
            Step::SpawnContainer {
                name,
                image,
                cmd,
                volumes,
                privileged,
                ..
            } => {
                let client = Docker::unix(&CONFIG.docker.socket);

                let mut opts_builder = ContainerCreateOpts::builder(image)
                    .name(name)
                    .volumes(volumes)
                    .privileged(*privileged)
                    .auto_remove(true);

                if let Some(cmd) = cmd {
                    opts_builder = opts_builder.cmd(cmd.split_whitespace())
                }

                let opts = opts_builder.build();
                let container = client.containers().create(&opts).await?;
                container.start().await?;

                Ok(())
            }
            Step::KillContainer { name, .. } => {
                let client = Docker::unix(&CONFIG.docker.socket);

                let container = client.containers().get(name);
                container.kill(None).await?;

                Ok(())
            }
            Step::Host { script, .. } => {
                use std::process::{Command, Stdio};

                for cmd in script {
                    let out = Command::new(&cmd.command)
                        .stdout(Stdio::piped())
                        .stderr(Stdio::piped())
                        .args(&cmd.args)
                        .output()
                        .map_err(anyhow::Error::from)
                        .context("failed to run command")?;

                    let stdout = String::from_utf8(out.stdout).unwrap_or("".into());
                    let stderr = String::from_utf8(out.stderr).unwrap_or("".into());

                    let cmd_str = std::iter::once(&cmd.command)
                        .chain(&cmd.args)
                        .fold(String::new(), |s, a| s + " " + a);

                    tracing::debug!(
                        stdout = ?stdout,
                        stderr = ?stderr,
                        "command `{}` stdio",
                        cmd_str
                    );

                    let status = out.status;
                    if !status.success() {
                        match status.code() {
                            Some(code) => bail!("command failed with exit code: {}", code),
                            None => {
                                bail!(
                                    "command exited with signal: {}",
                                    status
                                        .signal()
                                        .expect("No signal or exit code for process!?")
                                )
                            }
                        }
                    }
                }

                Ok(())
            }
            Step::Container {
                name,
                script,
                privileged,
                tty,
                ..
            } => {
                use crate::docker::{Command, ExitCode, Stdio};

                for cmd in script {
                    let output = Command::new(name.to_owned(), &cmd.command)
                        .args(&cmd.args)
                        .stdout(Stdio::Piped)
                        .stderr(Stdio::Piped)
                        .tty(*tty)
                        .privileged(*privileged)
                        .output()
                        .await
                        .context("failed to run command in container")?;

                    let stdout = String::from_utf8(output.stdout).unwrap_or("".into());
                    let stderr = String::from_utf8(output.stderr).unwrap_or("".into());

                    let cmd_str = std::iter::once(&cmd.command)
                        .chain(&cmd.args)
                        .fold(String::new(), |s, a| s + " " + a);

                    tracing::debug!(
                        stdout = ?stdout,
                        stderr = ?stderr,
                        "command `{}` stdio",
                        cmd_str
                    );

                    match output.code {
                        Some(ExitCode(0)) => continue,
                        Some(ExitCode(code)) => {
                            bail!("command failed with exit code: {}", code)
                        }
                        None => {
                            bail!("command did not have an exit status!?")
                        }
                    }
                }

                Ok(())
            }
            Step::Wait { for_ } => {
                match for_ {
                    Wait::Sleep(dur) => {
                        std::thread::sleep(*dur);
                    }
                    Wait::Input {} => {
                        tracing::info!("waiting for input on stdin...");
                        let _ = stdin().read(&mut [0]);
                    }
                };

                Ok(())
            }
        }
    }

    /// Run the step and return either its `Step::success_mode()` or
    /// `Step::failure_mode()` depending on whether it succeeded or not.
    pub async fn run(&self) -> ExploitStatus {
        match self.do_run().await {
            Ok(_) => {
                let status = self.success_mode();
                tracing::info!(step = ?self, status = ?status, "step succeeded");
                status
            }
            Err(e) => {
                let status = self.failure_mode();
                tracing::info!(error = ?e, step = ?self, status = ?status, "step failed");
                status
            }
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Copy)]
#[serde(rename_all = "camelCase")]
pub enum ExploitStatus {
    /// The status of the exploit test is undecided.
    Undecided,
    /// Setup has failed.
    /// This is a final status that stops the plan.
    SetupFailure,
    /// The exploit has succeeded.
    /// This is a final status that stops the plan.
    ExploitSuccess,
    /// The exploit has failed.
    /// This is a final status that stops the plan.
    ExploitFailure,
}

impl ExploitStatus {
    pub fn is_final(&self) -> bool {
        match self {
            ExploitStatus::Undecided => false,
            ExploitStatus::SetupFailure => true,
            ExploitStatus::ExploitSuccess => true,
            ExploitStatus::ExploitFailure => true,
        }
    }
}

impl Default for ExploitStatus {
    fn default() -> Self {
        ExploitStatus::Undecided
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tracing_test::traced_test;

    #[test]
    #[traced_test]
    fn test_yaml_plan_serde_smoke() {
        use serde_yaml::{from_str, to_string};

        let yaml = r#"
            steps:
            - spawnContainer:
                name: bash
                image: bash
            - host:
                script:
                - command: docker
                  args: ["cp", "/etc/passwd", "bash:/passwd"]
                failure: setupFailure
            - wait:
                sleep: 2s
            - wait:
                input: {}
            - container:
                name: bash
                script:
                - command: cat
                  args: ["/passwd"]
                failure: exploitFailure
                success: exploitSuccess
            "#;

        let plan: Plan = from_str(yaml).expect("should deserialize");
        println!("{plan:#?}");

        let yaml = to_string(&plan).expect("should serialize");
        let plan2: Plan = from_str(&yaml).expect("should deserialize back");

        assert_eq!(plan, plan2, "deserialized structs should be the same");
    }

    #[tokio::test]
    #[traced_test]
    #[serial_test::serial]
    async fn test_spawn_container() {
        use serde_yaml::from_str;

        let yaml = r#"
            steps:
            - spawnContainer:
                name: bash
                image: bash
                cmd: sleep infinity
            - host:
                script:
                - command: echo
                  args: ["hello"]
                - command: echo
                  args: ["goodbye"]
                failure: exploitFailure
            - container:
                name: bash
                script:
                - command: echo
                  args: ["hello"]
                - command: echo
                  args: ["goodbye"]
                failure: exploitFailure
                success: exploitSuccess
            "#;

        let plan: Plan = from_str(yaml).expect("should deserialize");
        let status = plan.run().await;
        assert!(
            matches!(status, ExploitStatus::ExploitSuccess),
            "should succeed"
        );
    }

    #[tokio::test]
    #[traced_test]
    #[serial_test::serial]
    async fn test_exploits_work() {
        use std::path::PathBuf;

        let mut d = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        d.push("exploits");

        for entry in jwalk::WalkDir::new(d)
            .follow_links(false)
            .into_iter()
            .filter_map(Result::ok)
            .filter(|e| e.path().is_file())
        {
            if let Ok(f) = std::fs::File::open(entry.path()) {
                let plan: Plan = serde_yaml::from_reader(f).expect("should deserialize");
                let status = plan.run().await;
                assert!(
                    matches!(status, ExploitStatus::ExploitSuccess),
                    "exploit should succeed"
                );
            }
        }
    }
}
